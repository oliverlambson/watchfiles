{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"watchfiles","text":"<p>Documentation for version: v1.1.1.</p> <p>Simple, modern and high performance file watching and code reload in python.</p> <p>Underlying file system notifications are handled by the Notify rust library.</p> <p>This package was previously named \"watchgod\", see Migrating from watchgod for more information.</p>"},{"location":"#usage","title":"Usage","text":"<p>Here are some examples of what watchfiles can do:</p> <p>watch Usage<pre><code>from watchfiles import watch\n\nfor changes in watch('./path/to/dir'):\n    print(changes)\n</code></pre> See <code>watch</code> docs for more details.</p> <p><code>watch</code> (and all other methods) can watch either files or directories and can watch more than one path with a single instance.</p> <p>awatch Usage<pre><code>import asyncio\nfrom watchfiles import awatch\n\nasync def main():\n    async for changes in awatch('/path/to/dir'):\n        print(changes)\n\nasyncio.run(main())\n</code></pre> See <code>awatch</code> docs for more details.</p> <p>run_process Usage<pre><code>from watchfiles import run_process\n\ndef foobar(a, b, c):\n    ...\n\nif __name__ == '__main__':\n    run_process('./path/to/dir', target=foobar, args=(1, 2, 3))\n</code></pre> See <code>run_process</code> docs for more details.</p> <p>arun_process Usage<pre><code>import asyncio\nfrom watchfiles import arun_process\n\ndef foobar(a, b, c):\n    ...\n\nasync def main():\n    await arun_process('./path/to/dir', target=foobar, args=(1, 2, 3))\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre> See <code>arun_process</code> docs for more details.</p>"},{"location":"#installation","title":"Installation","text":"<p>watchfiles requires Python 3.9 to Python 3.14.</p>"},{"location":"#from-pypi","title":"From PyPI","text":"<p>Using <code>pip</code>:</p> <pre><code>pip install watchfiles\n</code></pre> <p>Binaries are available for:</p> <ul> <li>Linux: <code>x86_64</code>, <code>aarch64</code>, <code>i686</code>, <code>armv7l</code>, <code>musl-x86_64</code> &amp; <code>musl-aarch64</code></li> <li>MacOS: <code>x86_64</code> &amp; <code>aarch64</code></li> <li>Windows: <code>x86_64</code>, <code>aarch64</code> &amp; <code>i686</code></li> </ul>"},{"location":"#from-conda-forge","title":"From conda-forge","text":"<p>Using <code>conda</code> or <code>mamba</code>:</p> <pre><code>mamba install -c conda-forge watchfiles\n</code></pre> <p>Binaries are available for:</p> <ul> <li>Linux: <code>x86_64</code></li> <li>MacOS: <code>x86_64</code> &amp; <code>arm64</code> (except python 3.7)</li> <li>Windows: <code>amd64</code></li> </ul>"},{"location":"#from-source","title":"From source","text":"<p>You can also install from source which requires Rust stable to be installed.</p>"},{"location":"#how-watchfiles-works","title":"How Watchfiles Works","text":"<p>watchfiles is based on the Notify rust library.</p> <p>All the hard work of integrating with the OS's file system events notifications and falling back to polling is palmed off onto the rust library.</p> <p>\"Debouncing\" changes - e.g. grouping changes into batches rather than firing a yield/reload for each file changed is managed in rust.</p> <p>The rust code takes care of creating a new thread to watch for file changes so in the case of the synchronous methods (<code>watch</code> and <code>run_process</code>) no threading logic is required in python. When using the asynchronous methods (<code>awatch</code> and <code>arun_process</code>) <code>anyio.to_thread.run_sync</code> is used to wait for changes in a thread.</p>"},{"location":"cli/","title":"CLI","text":"<p>watchfiles comes with a CLI for running and reloading code, the CLI uses watchfiles.run_process to run the code and like <code>run_process</code> can either run a python function or a shell-like command.</p> <p>The CLI can be used either via <code>watchfiles ...</code> or <code>python -m watchfiles ...</code>.</p>"},{"location":"cli/#running-and-restarting-a-python-function","title":"Running and restarting a python function","text":"<p>Let's say you have <code>foobar.py</code> (in this case a very simple web server using aiohttp) which gets details about recent file changes from the <code>WATCHFILES_CHANGES</code> environment variable (see <code>run_process</code> docs) and returns them as JSON.</p> foobar.py<pre><code>import os, json\nfrom aiohttp import web\n\nasync def handle(request):\n    # get the most recent file changes and return them\n    changes = os.getenv('WATCHFILES_CHANGES')\n    changes = json.loads(changes)\n    return web.json_response(dict(changes=changes))\n\napp = web.Application()\napp.router.add_get('/', handle)\n\ndef main():\n    web.run_app(app, port=8000)\n</code></pre> <p>You could run this and reload it when any file in the current directory changes with:</p> Running a python function<pre><code>watchfiles foobar.main\n</code></pre>"},{"location":"cli/#running-and-restarting-a-command","title":"Running and restarting a command","text":"<p>Let's say you want to re-run failing tests whenever files change. You could do this with watchfiles using</p> Running a command<pre><code>watchfiles 'pytest --lf'\n</code></pre> <p>(pytest's <code>--lf</code> option is a shortcut for <code>--last-failed</code>, see pytest docs)</p> <p>By default the CLI will watch the current directory and all subdirectories, but the directory/directories watched can be changed.</p> <p>In this example, we might want to watch only the <code>src</code> and <code>tests</code> directories, and only react to changes in python files:</p> Watching custom directories and files<pre><code>watchfiles --filter python 'pytest --lf' src tests\n</code></pre>"},{"location":"cli/#help","title":"Help","text":"<p>Run <code>watchfiles --help</code> for more options.</p> watchfiles --help<pre><code>usage: watchfiles [-h] [--ignore-paths [IGNORE_PATHS]]\n                  [--target-type [{command,function,auto}]]\n                  [--filter [FILTER]] [--args [ARGS]] [--verbose]\n                  [--non-recursive] [--verbosity [{warning,info,debug}]]\n                  [--sigint-timeout [SIGINT_TIMEOUT]]\n                  [--grace-period [GRACE_PERIOD]]\n                  [--sigkill-timeout [SIGKILL_TIMEOUT]]\n                  [--ignore-permission-denied] [--version]\n                  target [paths ...]\n\nWatch one or more directories and execute either a shell command or a python function on file changes.\n\nExample of watching the current directory and calling a python function:\n\n    watchfiles foobar.main\n\nExample of watching python files in two local directories and calling a shell command:\n\n    watchfiles --filter python 'pytest --lf' src tests\n\nSee https://watchfiles.helpmanual.io/cli/ for more information.\n\npositional arguments:\n  target                Command or dotted function path to run\n  paths                 Filesystem paths to watch, defaults to current directory\n\noptions:\n  -h, --help            show this help message and exit\n  --ignore-paths [IGNORE_PATHS]\n                        Specify directories to ignore, to ignore multiple paths use a comma as separator, e.g. \"env\" or \"env,node_modules\"\n  --target-type [{command,function,auto}]\n                        Whether the target should be intercepted as a shell command or a python function, defaults to \"auto\" which infers the target type from the target string\n  --filter [FILTER]     Which files to watch, defaults to \"default\" which uses the \"DefaultFilter\", \"python\" uses the \"PythonFilter\", \"all\" uses no filter, any other value is interpreted as a python function/class path which is imported\n  --args [ARGS]         Arguments to set on sys.argv before calling target function, used only if the target is a function\n  --verbose             Set log level to \"debug\", wins over `--verbosity`\n  --non-recursive       Do not watch for changes in sub-directories recursively\n  --verbosity [{warning,info,debug}]\n                        Log level, defaults to \"info\"\n  --sigint-timeout [SIGINT_TIMEOUT]\n                        How long to wait for the sigint timeout before sending sigkill.\n  --grace-period [GRACE_PERIOD]\n                        Number of seconds after the process is started before watching for changes.\n  --sigkill-timeout [SIGKILL_TIMEOUT]\n                        How long to wait for the sigkill timeout before issuing a timeout exception.\n  --ignore-permission-denied\n                        Ignore permission denied errors while watching files and directories.\n  --version, -V         show program's version number and exit\n</code></pre>"},{"location":"migrating/","title":"Migration from watchgod","text":"<p>This package was significantly rewritten and renamed from <code>watchgod</code> to <code>watchfiles</code>, these docs refer to the new <code>watchfiles</code> package.</p> <p>The main reason for this change was to avoid confusion with the similarly named \"watchdog\" package, see #102 for more details.</p> <p>The most significant code change was to switch from file scanning/polling to OS file system notifications using the Notify rust library. This is much more performant than the old approach.</p> <p>As a result, the external interface to the library has been changed somewhat.</p> <p>The main methods:</p> <ul> <li><code>watch</code></li> <li><code>awatch</code></li> <li><code>run_process</code></li> <li><code>arun_process</code></li> </ul> <p>All remain, the following changes affect them all:</p> <ul> <li><code>watcher_cls</code> is removed and replaced by <code>watch_filter</code> which should be a simple callable,   see filter docs</li> <li>all these methods allow multiple paths to be watched, as result, the <code>target</code> argument to <code>run_process</code>   &amp; <code>arun_process</code> is now keyword-only</li> <li>the other optional keyword arguments have changed somewhat, mostly as a result of cleanup, all public   methods are now thoroughly documented</li> </ul>"},{"location":"migrating/#the-old-watchgod-package-remains","title":"The old <code>watchgod</code> package remains","text":"<p>The old <code>watchgod</code> pypi package remains, I'll add a notice about the new package name, but otherwise It'll continue to work (in future, it might get deprecation warnings).</p> <p>Documentation is available in the old README.</p>"},{"location":"api/filters/","title":"Filters","text":"<p>All classes described here are designed to be used for the <code>watch_filter</code> argument to the <code>watch</code> function and similar.</p> <p>This argument requires a simple callable which takes two arguments (the <code>Change</code> type and the path as a string) and returns a boolean indicating if the change should be included (<code>True</code>) or ignored (<code>False</code>).</p> <p>As shown below in Custom Filters, you can either a <code>BaseFilter</code> subclass instance or your own callable.</p>"},{"location":"api/filters/#watchfiles.BaseFilter","title":"BaseFilter","text":"<pre><code>BaseFilter()\n</code></pre> <p>Useful base class for creating filters. <code>BaseFilter</code> should be inherited and configured, rather than used directly.</p> <p>The class supports ignoring files in 3 ways:</p>"},{"location":"api/filters/#watchfiles.BaseFilter.ignore_dirs","title":"ignore_dirs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignore_dirs: Sequence[str] = ()\n</code></pre> <p>Full names of directories to ignore, an obvious example would be <code>.git</code>.</p>"},{"location":"api/filters/#watchfiles.BaseFilter.ignore_entity_patterns","title":"ignore_entity_patterns  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignore_entity_patterns: Sequence[str] = ()\n</code></pre> <p>Patterns of files or directories to ignore, these are compiled into regexes.</p> <p>\"entity\" here refers to the specific file or directory - basically the result of <code>path.split(os.sep)[-1]</code>, an obvious example would be <code>r'\\.py[cod]$'</code>.</p>"},{"location":"api/filters/#watchfiles.BaseFilter.ignore_paths","title":"ignore_paths  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignore_paths: Sequence[Union[str, Path]] = ()\n</code></pre> <p>Full paths to ignore, e.g. <code>/home/users/.cache</code> or <code>C:\\Users\\user\\.cache</code>.</p>"},{"location":"api/filters/#watchfiles.BaseFilter.__call__","title":"__call__","text":"<pre><code>__call__(change: Change, path: str) -&gt; bool\n</code></pre> <p>Instances of <code>BaseFilter</code> subclasses can be used as callables. Args:     change: The type of change that occurred, see <code>Change</code>.     path: the raw path of the file or directory that changed.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the file should be included in changes, False if it should be ignored.</p>"},{"location":"api/filters/#watchfiles.DefaultFilter","title":"DefaultFilter","text":"<pre><code>DefaultFilter(*, ignore_dirs: Optional[Sequence[str]] = None, ignore_entity_patterns: Optional[Sequence[str]] = None, ignore_paths: Optional[Sequence[Union[str, Path]]] = None)\n</code></pre> <p>               Bases: <code>BaseFilter</code></p> <p>The default filter, which ignores files and directories that you might commonly want to ignore.</p> <p>Parameters:</p> Name Type Description Default <code>ignore_dirs</code> <code>Optional[Sequence[str]]</code> <p>if not <code>None</code>, overrides the <code>ignore_dirs</code> value set on the class.</p> <code>None</code> <code>ignore_entity_patterns</code> <code>Optional[Sequence[str]]</code> <p>if not <code>None</code>, overrides the <code>ignore_entity_patterns</code> value set on the class.</p> <code>None</code> <code>ignore_paths</code> <code>Optional[Sequence[Union[str, Path]]]</code> <p>if not <code>None</code>, overrides the <code>ignore_paths</code> value set on the class.</p> <code>None</code>"},{"location":"api/filters/#watchfiles.DefaultFilter.ignore_dirs","title":"ignore_dirs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignore_dirs: Sequence[str] = ('__pycache__', '.git', '.hg', '.svn', '.tox', '.venv', '.idea', 'node_modules', '.mypy_cache', '.pytest_cache', '.hypothesis')\n</code></pre> <p>Directory names to ignore.</p>"},{"location":"api/filters/#watchfiles.DefaultFilter.ignore_entity_patterns","title":"ignore_entity_patterns  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ignore_entity_patterns: Sequence[str] = ('\\\\.py[cod]$', '\\\\.___jb_...___$', '\\\\.sw.$', '~$', '^\\\\.\\\\#', '^\\\\.DS_Store$', '^flycheck_')\n</code></pre> <p>File/Directory name patterns to ignore.</p>"},{"location":"api/filters/#watchfiles.PythonFilter","title":"PythonFilter","text":"<pre><code>PythonFilter(*, ignore_paths: Optional[Sequence[Union[str, Path]]] = None, extra_extensions: Sequence[str] = ())\n</code></pre> <p>               Bases: <code>DefaultFilter</code></p> <p>A filter for Python files, since this class inherits from <code>DefaultFilter</code> it will ignore files and directories that you might commonly want to ignore as well as filtering out all changes except in Python files (files with extensions <code>('.py', '.pyx', '.pyd')</code>).</p> <p>Parameters:</p> Name Type Description Default <code>ignore_paths</code> <code>Optional[Sequence[Union[str, Path]]]</code> <p>The paths to ignore, see <code>BaseFilter</code>.</p> <code>None</code> <code>extra_extensions</code> <code>Sequence[str]</code> <p>extra extensions to ignore.</p> <code>()</code> <p><code>ignore_paths</code> and <code>extra_extensions</code> can be passed as arguments partly to support CLI usage where <code>--ignore-paths</code> and <code>--extensions</code> can be passed as arguments.</p>"},{"location":"api/filters/#custom-filters","title":"Custom Filters","text":"<p>Here's an example of a custom filter which extends <code>DefaultFilter</code> to only notice changes to common web files:</p> <pre><code>from watchfiles import Change, DefaultFilter, watch\n\n\nclass WebFilter(DefaultFilter):\n    allowed_extensions = '.html', '.css', '.js'\n\n    def __call__(self, change: Change, path: str) -&gt; bool:\n        return (\n            super().__call__(change, path) and\n            path.endswith(self.allowed_extensions)\n        )\n\nfor changes in watch('my/web/project', watch_filter=WebFilter()):\n    print (changes)\n</code></pre> <p>Here's an example of a customer filter which is a simple callable that ignores changes unless they represent a new file being created:</p> <pre><code>from watchfiles import Change, watch\n\ndef only_added(change: Change, path: str) -&gt; bool:\n    return change == Change.added\n\nfor changes in watch('my/project', watch_filter=only_added):\n    print (changes)\n</code></pre> <p>For more details, see <code>filters.py</code>.</p>"},{"location":"api/run_process/","title":"Run process","text":""},{"location":"api/run_process/#watchfiles.run_process","title":"run_process","text":"<pre><code>run_process(*paths: Union[Path, str], target: Union[str, Callable[..., Any]], args: Tuple[Any, ...] = (), kwargs: Optional[Dict[str, Any]] = None, target_type: Literal['function', 'command', 'auto'] = 'auto', callback: Optional[Callable[[Set[FileChange]], None]] = None, watch_filter: Optional[Callable[[Change, str], bool]] = DefaultFilter(), grace_period: float = 0, debounce: int = 1600, step: int = 50, debug: Optional[bool] = None, sigint_timeout: int = 5, sigkill_timeout: int = 1, recursive: bool = True, ignore_permission_denied: bool = False) -&gt; int\n</code></pre> <p>Run a process and restart it upon file changes.</p> <p><code>run_process</code> can work in two ways:</p> <ul> <li>Using <code>multiprocessing.Process</code> \u2020 to run a python function</li> <li>Or, using <code>subprocess.Popen</code> to run a command</li> </ul> <p>Note</p> <p>\u2020 technically <code>multiprocessing.get_context('spawn').Process</code> to avoid forking and improve code reload/import.</p> <p>Internally, <code>run_process</code> uses <code>watch</code> with <code>raise_interrupt=False</code> so the function exits cleanly upon <code>Ctrl+C</code>.</p> <p>Parameters:</p> Name Type Description Default <code>*paths</code> <code>Union[Path, str]</code> <p>matches the same argument of <code>watch</code></p> <code>()</code> <code>target</code> <code>Union[str, Callable[..., Any]]</code> <p>function or command to run</p> required <code>args</code> <code>Tuple[Any, ...]</code> <p>arguments to pass to <code>target</code>, only used if <code>target</code> is a function</p> <code>()</code> <code>kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>keyword arguments to pass to <code>target</code>, only used if <code>target</code> is a function</p> <code>None</code> <code>target_type</code> <code>Literal['function', 'command', 'auto']</code> <p>type of target. Can be <code>'function'</code>, <code>'command'</code>, or <code>'auto'</code> in which case <code>detect_target_type</code> is used to determine the type.</p> <code>'auto'</code> <code>callback</code> <code>Optional[Callable[[Set[FileChange]], None]]</code> <p>function to call on each reload, the function should accept a set of changes as the sole argument</p> <code>None</code> <code>watch_filter</code> <code>Optional[Callable[[Change, str], bool]]</code> <p>matches the same argument of <code>watch</code></p> <code>DefaultFilter()</code> <code>grace_period</code> <code>float</code> <p>number of seconds after the process is started before watching for changes</p> <code>0</code> <code>debounce</code> <code>int</code> <p>matches the same argument of <code>watch</code></p> <code>1600</code> <code>step</code> <code>int</code> <p>matches the same argument of <code>watch</code></p> <code>50</code> <code>debug</code> <code>Optional[bool]</code> <p>matches the same argument of <code>watch</code></p> <code>None</code> <code>sigint_timeout</code> <code>int</code> <p>the number of seconds to wait after sending sigint before sending sigkill</p> <code>5</code> <code>sigkill_timeout</code> <code>int</code> <p>the number of seconds to wait after sending sigkill before raising an exception</p> <code>1</code> <code>recursive</code> <code>bool</code> <p>matches the same argument of <code>watch</code></p> <code>True</code> <p>Returns:</p> Type Description <code>int</code> <p>number of times the function was reloaded.</p> Example of run_process running a function<pre><code>from watchfiles import run_process\n\ndef callback(changes):\n    print('changes detected:', changes)\n\ndef foobar(a, b):\n    print('foobar called with:', a, b)\n\nif __name__ == '__main__':\n    run_process('./path/to/dir', target=foobar, args=(1, 2), callback=callback)\n</code></pre> <p>As well as using a <code>callback</code> function, changes can be accessed from within the target function, using the <code>WATCHFILES_CHANGES</code> environment variable.</p> Example of run_process accessing changes<pre><code>from watchfiles import run_process\n\ndef foobar(a, b, c):\n    # changes will be an empty list \"[]\" the first time the function is called\n    changes = os.getenv('WATCHFILES_CHANGES')\n    changes = json.loads(changes)\n    print('foobar called due to changes:', changes)\n\nif __name__ == '__main__':\n    run_process('./path/to/dir', target=foobar, args=(1, 2, 3))\n</code></pre> <p>Again with the target as <code>command</code>, <code>WATCHFILES_CHANGES</code> can be used to access changes.</p> example.sh<pre><code>echo \"changers: ${WATCHFILES_CHANGES}\"\n</code></pre> Example of run_process running a command<pre><code>from watchfiles import run_process\n\nif __name__ == '__main__':\n    run_process('.', target='./example.sh')\n</code></pre>"},{"location":"api/run_process/#watchfiles.arun_process","title":"arun_process  <code>async</code>","text":"<pre><code>arun_process(*paths: Union[Path, str], target: Union[str, Callable[..., Any]], args: Tuple[Any, ...] = (), kwargs: Optional[Dict[str, Any]] = None, target_type: Literal['function', 'command', 'auto'] = 'auto', callback: Optional[Callable[[Set[FileChange]], Any]] = None, watch_filter: Optional[Callable[[Change, str], bool]] = DefaultFilter(), grace_period: float = 0, debounce: int = 1600, step: int = 50, debug: Optional[bool] = None, recursive: bool = True, ignore_permission_denied: bool = False) -&gt; int\n</code></pre> <p>Async equivalent of <code>run_process</code>, all arguments match those of <code>run_process</code> except <code>callback</code> which can be a coroutine.</p> <p>Starting and stopping the process and watching for changes is done in a separate thread.</p> <p>As with <code>run_process</code>, internally <code>arun_process</code> uses <code>awatch</code>, however <code>KeyboardInterrupt</code> cannot be caught and suppressed in <code>awatch</code> so these errors need to be caught separately, see below.</p> Example of arun_process usage<pre><code>import asyncio\nfrom watchfiles import arun_process\n\nasync def callback(changes):\n    await asyncio.sleep(0.1)\n    print('changes detected:', changes)\n\ndef foobar(a, b):\n    print('foobar called with:', a, b)\n\nasync def main():\n    await arun_process('.', target=foobar, args=(1, 2), callback=callback)\n\nif __name__ == '__main__':\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        print('stopped via KeyboardInterrupt')\n</code></pre>"},{"location":"api/run_process/#watchfiles.run.detect_target_type","title":"detect_target_type","text":"<pre><code>detect_target_type(target: Union[str, Callable[..., Any]]) -&gt; Literal['function', 'command']\n</code></pre> <p>Used by <code>run_process</code>, <code>arun_process</code> and indirectly the CLI to determine the target type with <code>target_type</code> is <code>auto</code>.</p> <p>Detects the target type - either <code>function</code> or <code>command</code>. This method is only called with <code>target_type='auto'</code>.</p> <p>The following logic is employed:</p> <ul> <li>If <code>target</code> is not a string, it is assumed to be a function</li> <li>If <code>target</code> ends with <code>.py</code> or <code>.sh</code>, it is assumed to be a command</li> <li>Otherwise, the target is assumed to be a function if it matches the regex <code>[a-zA-Z0-9_]+(\\.[a-zA-Z0-9_]+)+</code></li> </ul> <p>If this logic does not work for you, specify the target type explicitly using the <code>target_type</code> function argument or <code>--target-type</code> command line argument.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Union[str, Callable[..., Any]]</code> <p>The target value</p> required <p>Returns:</p> Type Description <code>Literal['function', 'command']</code> <p>either <code>'function'</code> or <code>'command'</code></p>"},{"location":"api/rust_backend/","title":"Rust backend direct usage","text":""},{"location":"api/rust_backend/#watchfiles._rust_notify.RustNotify","title":"RustNotify","text":"<pre><code>RustNotify(watch_paths: list[str], debug: bool, force_polling: bool, poll_delay_ms: int, recursive: bool, ignore_permission_denied: bool)\n</code></pre> <p>Interface to the Rust notify crate which does the heavy lifting of watching for file changes and grouping them into events.</p> <p>Create a new <code>RustNotify</code> instance and start a thread to watch for changes.</p> <p><code>FileNotFoundError</code> is raised if any of the paths do not exist.</p> <p>Parameters:</p> Name Type Description Default <code>watch_paths</code> <code>list[str]</code> <p>file system paths to watch for changes, can be directories or files</p> required <code>debug</code> <code>bool</code> <p>if true, print details about all events to stderr</p> required <code>force_polling</code> <code>bool</code> <p>if true, always use polling instead of file system notifications</p> required <code>poll_delay_ms</code> <code>int</code> <p>delay between polling for changes, only used if <code>force_polling=True</code></p> required <code>recursive</code> <code>bool</code> <p>if <code>True</code>, watch for changes in sub-directories recursively, otherwise watch only for changes in the top-level directory, default is <code>True</code>.</p> required <code>ignore_permission_denied</code> <code>bool</code> <p>if <code>True</code>, permission denied errors are ignored while watching changes.</p> required"},{"location":"api/rust_backend/#watchfiles._rust_notify.RustNotify.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; RustNotify\n</code></pre> <p>Does nothing, but allows <code>RustNotify</code> to be used as a context manager.</p> <p>Note</p> <p>The watching thead is created when an instance is initiated, not on <code>__enter__</code>.</p>"},{"location":"api/rust_backend/#watchfiles._rust_notify.RustNotify.__exit__","title":"__exit__","text":"<pre><code>__exit__(*args: Any) -&gt; None\n</code></pre> <p>Calls <code>close</code>.</p>"},{"location":"api/rust_backend/#watchfiles._rust_notify.RustNotify.close","title":"close","text":"<pre><code>close() -&gt; None\n</code></pre> <p>Stops the watching thread. After <code>close</code> is called, the <code>RustNotify</code> instance can no longer be used, calls to <code>watch</code> will raise a <code>RuntimeError</code>.</p> <p>Note</p> <p><code>close</code> is not required, just deleting the <code>RustNotify</code> instance will kill the thread implicitly.</p> <p>As per #163 <code>close()</code> is only required because in the event of an error, the traceback in <code>sys.exc_info</code> keeps a reference to <code>watchfiles.watch</code>'s frame, so you can't rely on the <code>RustNotify</code> object being deleted, and thereby stopping the watching thread.</p>"},{"location":"api/rust_backend/#watchfiles._rust_notify.RustNotify.watch","title":"watch","text":"<pre><code>watch(debounce_ms: int, step_ms: int, timeout_ms: int, stop_event: AbstractEvent | None) -&gt; set[tuple[int, str]] | Literal['signal', 'stop', 'timeout']\n</code></pre> <p>Watch for changes.</p> <p>This method will wait <code>timeout_ms</code> milliseconds for changes, but once a change is detected, it will group changes and return in no more than <code>debounce_ms</code> milliseconds.</p> <p>The GIL is released during a <code>step_ms</code> sleep on each iteration to avoid blocking python.</p> <p>Parameters:</p> Name Type Description Default <code>debounce_ms</code> <code>int</code> <p>maximum time in milliseconds to group changes over before returning.</p> required <code>step_ms</code> <code>int</code> <p>time to wait for new changes in milliseconds, if no changes are detected in this time, and at least one change has been detected, the changes are yielded.</p> required <code>timeout_ms</code> <code>int</code> <p>maximum time in milliseconds to wait for changes before returning, <code>0</code> means wait indefinitely, <code>debounce_ms</code> takes precedence over <code>timeout_ms</code> once a change is detected.</p> required <code>stop_event</code> <code>AbstractEvent | None</code> <p>event to check on every iteration to see if this function should return early. The event should be an object which has an <code>is_set()</code> method which returns a boolean.</p> required <p>Returns:</p> Type Description <code>set[tuple[int, str]] | Literal['signal', 'stop', 'timeout']</code> <p>See below.</p> <p>Return values have the following meanings:</p> <ul> <li>Change details as a <code>set</code> of <code>(event_type, path)</code> tuples, the event types are ints which match   <code>Change</code>, <code>path</code> is a string representing the path of the file that changed</li> <li><code>'signal'</code> string, if a signal was received</li> <li><code>'stop'</code> string, if the <code>stop_event</code> was set</li> <li><code>'timeout'</code> string, if <code>timeout_ms</code> was exceeded</li> </ul>"},{"location":"api/rust_backend/#watchfiles._rust_notify.WatchfilesRustInternalError","title":"WatchfilesRustInternalError","text":"<p>               Bases: <code>RuntimeError</code></p> <p>Raised when RustNotify encounters an unknown error.</p> <p>If you get this a lot, please check github issues and create a new issue if your problem is not discussed.</p>"},{"location":"api/rust_backend/#watchfiles._rust_notify.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__: str\n</code></pre> <p>The package version as defined in <code>Cargo.toml</code>, modified to match python's versioning semantics.</p>"},{"location":"api/rust_backend/#rust-backend-direct-usage","title":"Rust backend direct usage","text":"<p>The rust backend can be accessed directly as follows:</p> Rust backend example<pre><code>from watchfiles._rust_notify import RustNotify\n\nr = RustNotify(['first/path', 'second/path'], False, False, 0, True, False)\n\nchanges = r.watch(1_600, 50, 100, None)\nprint(changes)\n\nr.close()\n</code></pre> <p>Or using <code>RustNotify</code> as a context manager:</p> Rust backend context manager example<pre><code>from watchfiles._rust_notify import RustNotify\n\nwith RustNotify(['first/path', 'second/path'], False, False, 0, True, False) as r:\n    changes = r.watch(1_600, 50, 100, None)\n    print(changes)\n</code></pre> <p>(See the documentation on <code>close</code> above for when and why the context manager or <code>close</code> method are required.)</p>"},{"location":"api/watch/","title":"Watch","text":""},{"location":"api/watch/#watchfiles.watch","title":"watch","text":"<pre><code>watch(*paths: Union[Path, str], watch_filter: Optional[Callable[[Change, str], bool]] = DefaultFilter(), debounce: int = 1600, step: int = 50, stop_event: Optional[AbstractEvent] = None, rust_timeout: int = 5000, yield_on_timeout: bool = False, debug: Optional[bool] = None, raise_interrupt: bool = True, force_polling: Optional[bool] = None, poll_delay_ms: int = 300, recursive: bool = True, ignore_permission_denied: Optional[bool] = None) -&gt; Generator[Set[FileChange], None, None]\n</code></pre> <p>Watch one or more paths and yield a set of changes whenever files change.</p> <p>The paths watched can be directories or files, directories are watched recursively - changes in subdirectories are also detected.</p>"},{"location":"api/watch/#watchfiles.watch--force-polling","title":"Force polling","text":"<p>Notify will fall back to file polling if it can't use file system notifications, but we also force Notify to use polling if the <code>force_polling</code> argument is <code>True</code>; if <code>force_polling</code> is unset (or <code>None</code>), we enable force polling thus:</p> <ul> <li>if the <code>WATCHFILES_FORCE_POLLING</code> environment variable exists and is not empty:<ul> <li>if the value is <code>false</code>, <code>disable</code> or <code>disabled</code>, force polling is disabled</li> <li>otherwise, force polling is enabled</li> </ul> </li> <li>otherwise, we enable force polling only if we detect we're running on WSL (Windows Subsystem for Linux)</li> </ul> <p>It is also possible to change the poll delay between iterations, it can be changed to maintain a good response time and an appropiate CPU consumption using the <code>poll_delay_ms</code> argument, we change poll delay thus:</p> <ul> <li>if file polling is enabled and the <code>WATCHFILES_POLL_DELAY_MS</code> env var exists and it is numeric, we use that</li> <li>otherwise, we use the argument value</li> </ul> <p>Parameters:</p> Name Type Description Default <code>*paths</code> <code>Union[Path, str]</code> <p>filesystem paths to watch.</p> <code>()</code> <code>watch_filter</code> <code>Optional[Callable[[Change, str], bool]]</code> <p>callable used to filter out changes which are not important, you can either use a raw callable or a <code>BaseFilter</code> instance, defaults to an instance of <code>DefaultFilter</code>. To keep all changes, use <code>None</code>.</p> <code>DefaultFilter()</code> <code>debounce</code> <code>int</code> <p>maximum time in milliseconds to group changes over before yielding them.</p> <code>1600</code> <code>step</code> <code>int</code> <p>time to wait for new changes in milliseconds, if no changes are detected in this time, and at least one change has been detected, the changes are yielded.</p> <code>50</code> <code>stop_event</code> <code>Optional[AbstractEvent]</code> <p>event to stop watching, if this is set, the generator will stop iteration, this can be anything with an <code>is_set()</code> method which returns a bool, e.g. <code>threading.Event()</code>.</p> <code>None</code> <code>rust_timeout</code> <code>int</code> <p>maximum time in milliseconds to wait in the rust code for changes, <code>0</code> means no timeout.</p> <code>5000</code> <code>yield_on_timeout</code> <code>bool</code> <p>if <code>True</code>, the generator will yield upon timeout in rust even if no changes are detected.</p> <code>False</code> <code>debug</code> <code>Optional[bool]</code> <p>whether to print information about all filesystem changes in rust to stdout, if <code>None</code> will use the <code>WATCHFILES_DEBUG</code> environment variable.</p> <code>None</code> <code>raise_interrupt</code> <code>bool</code> <p>whether to re-raise <code>KeyboardInterrupt</code>s, or suppress the error and just stop iterating.</p> <code>True</code> <code>force_polling</code> <code>Optional[bool]</code> <p>See Force polling above.</p> <code>None</code> <code>poll_delay_ms</code> <code>int</code> <p>delay between polling for changes, only used if <code>force_polling=True</code>.</p> <code>300</code> <code>recursive</code> <code>bool</code> <p>if <code>True</code>, watch for changes in sub-directories recursively, otherwise watch only for changes in the top-level directory, default is <code>True</code>.</p> <code>True</code> <code>ignore_permission_denied</code> <code>Optional[bool]</code> <p>if <code>True</code>, will ignore permission denied errors, otherwise will raise them by default. Setting the <code>WATCHFILES_IGNORE_PERMISSION_DENIED</code> environment variable will set this value too.</p> <code>None</code> <p>Yields:</p> Type Description <code>Set[FileChange]</code> <p>The generator yields sets of <code>FileChange</code>s.</p> Example of watch usage<pre><code>from watchfiles import watch\n\nfor changes in watch('./first/dir', './second/dir', raise_interrupt=False):\n    print(changes)\n</code></pre>"},{"location":"api/watch/#watchfiles.awatch","title":"awatch  <code>async</code>","text":"<pre><code>awatch(*paths: Union[Path, str], watch_filter: Optional[Callable[[Change, str], bool]] = DefaultFilter(), debounce: int = 1600, step: int = 50, stop_event: Optional[AnyEvent] = None, rust_timeout: Optional[int] = None, yield_on_timeout: bool = False, debug: Optional[bool] = None, raise_interrupt: Optional[bool] = None, force_polling: Optional[bool] = None, poll_delay_ms: int = 300, recursive: bool = True, ignore_permission_denied: Optional[bool] = None) -&gt; AsyncGenerator[Set[FileChange], None]\n</code></pre> <p>Asynchronous equivalent of <code>watch</code> using threads to wait for changes. Arguments match those of <code>watch</code> except <code>stop_event</code>.</p> <p>All async methods use anyio to run the event loop.</p> <p>Unlike <code>watch</code> <code>KeyboardInterrupt</code> cannot be suppressed by <code>awatch</code> so they need to be caught where <code>asyncio.run</code> or equivalent is called.</p> <p>Parameters:</p> Name Type Description Default <code>*paths</code> <code>Union[Path, str]</code> <p>filesystem paths to watch.</p> <code>()</code> <code>watch_filter</code> <code>Optional[Callable[[Change, str], bool]]</code> <p>matches the same argument of <code>watch</code>.</p> <code>DefaultFilter()</code> <code>debounce</code> <code>int</code> <p>matches the same argument of <code>watch</code>.</p> <code>1600</code> <code>step</code> <code>int</code> <p>matches the same argument of <code>watch</code>.</p> <code>50</code> <code>stop_event</code> <code>Optional[AnyEvent]</code> <p><code>anyio.Event</code> which can be used to stop iteration, see example below.</p> <code>None</code> <code>rust_timeout</code> <code>Optional[int]</code> <p>matches the same argument of <code>watch</code>, except that <code>None</code> means use <code>1_000</code> on Windows and <code>5_000</code> on other platforms thus helping with exiting on <code>Ctrl+C</code> on Windows, see #110.</p> <code>None</code> <code>yield_on_timeout</code> <code>bool</code> <p>matches the same argument of <code>watch</code>.</p> <code>False</code> <code>debug</code> <code>Optional[bool]</code> <p>matches the same argument of <code>watch</code>.</p> <code>None</code> <code>raise_interrupt</code> <code>Optional[bool]</code> <p>This is deprecated, <code>KeyboardInterrupt</code> will cause this coroutine to be cancelled and then be raised by the top level <code>asyncio.run</code> call or equivalent, and should be caught there. See #136</p> <code>None</code> <code>force_polling</code> <code>Optional[bool]</code> <p>if true, always use polling instead of file system notifications, default is <code>None</code> where <code>force_polling</code> is set to <code>True</code> if the <code>WATCHFILES_FORCE_POLLING</code> environment variable exists.</p> <code>None</code> <code>poll_delay_ms</code> <code>int</code> <p>delay between polling for changes, only used if <code>force_polling=True</code>. <code>poll_delay_ms</code> can be changed via the <code>WATCHFILES_POLL_DELAY_MS</code> environment variable.</p> <code>300</code> <code>recursive</code> <code>bool</code> <p>if <code>True</code>, watch for changes in sub-directories recursively, otherwise watch only for changes in the top-level directory, default is <code>True</code>.</p> <code>True</code> <code>ignore_permission_denied</code> <code>Optional[bool]</code> <p>if <code>True</code>, will ignore permission denied errors, otherwise will raise them by default. Setting the <code>WATCHFILES_IGNORE_PERMISSION_DENIED</code> environment variable will set this value too.</p> <code>None</code> <p>Yields:</p> Type Description <code>AsyncGenerator[Set[FileChange], None]</code> <p>The generator yields sets of <code>FileChange</code>s.</p> Example of awatch usage<pre><code>import asyncio\nfrom watchfiles import awatch\n\nasync def main():\n    async for changes in awatch('./first/dir', './second/dir'):\n        print(changes)\n\nif __name__ == '__main__':\n    try:\n        asyncio.run(main())\n    except KeyboardInterrupt:\n        print('stopped via KeyboardInterrupt')\n</code></pre> Example of awatch usage with a stop event<pre><code>import asyncio\nfrom watchfiles import awatch\n\nasync def main():\n    stop_event = asyncio.Event()\n\n    async def stop_soon():\n        await asyncio.sleep(3)\n        stop_event.set()\n\n    stop_soon_task = asyncio.create_task(stop_soon())\n\n    async for changes in awatch('/path/to/dir', stop_event=stop_event):\n        print(changes)\n\n    # cleanup by awaiting the (now complete) stop_soon_task\n    await stop_soon_task\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/watch/#watchfiles.Change","title":"Change","text":"<p>               Bases: <code>IntEnum</code></p> <p>Enum representing the type of change that occurred.</p>"},{"location":"api/watch/#watchfiles.Change.added","title":"added  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>added = 1\n</code></pre> <p>A new file or directory was added.</p>"},{"location":"api/watch/#watchfiles.Change.deleted","title":"deleted  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>deleted = 3\n</code></pre> <p>A file or directory was deleted.</p>"},{"location":"api/watch/#watchfiles.Change.modified","title":"modified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>modified = 2\n</code></pre> <p>A file or directory was modified, can be either a metadata or data change.</p>"},{"location":"api/watch/#watchfiles.main.FileChange","title":"FileChange  <code>module-attribute</code>","text":"<pre><code>FileChange = Tuple[Change, str]\n</code></pre> <p>A tuple representing a file change, first element is a <code>Change</code> member, second is the path of the file or directory that changed.</p>"}]}